# views.py

from flask import Blueprint, request, flash, redirect, url_for, render_template, jsonify, send_file, make_response
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user
from werkzeug.utils import secure_filename
from werkzeug.security import generate_password_hash, check_password_hash
from .models import FileContent, User
from .extensions import db, login_manager
from io import BytesIO
import json
import subprocess
import psycopg2
import uuid
from kubernetes import client, config
import os
import hashlib
import platform
import numpy as np
import pandas as pd
from sqlalchemy import func
import plotly.graph_objs as go
import plotly.io as pio
import pyzipper
import io
import shutil

main = Blueprint('main', __name__)

def zip_file(file_content, password, filename):
    zip_buffer = io.BytesIO()
    with pyzipper.AESZipFile(zip_buffer, 'w', compression=pyzipper.ZIP_DEFLATED, encryption=pyzipper.WZ_AES) as zf:
        zf.setpassword(password.encode())
        zf.writestr(f'{filename}', file_content)
    return zip_buffer.getvalue()

# Function to fetch file from the database
def fetch_file_from_db(file_id, output_path, password):
    conn = psycopg2.connect(
        dbname="binaries",
        user="postgres",
        password=os.getenv('A_PASSWORD'),
        host="localhost",
        port="5432"
    )
    cursor = conn.cursor()
    
    query = "SELECT data FROM file_content WHERE id = %s"
    cursor.execute(query, (file_id,))
    zip_data = cursor.fetchone()[0]
    
    with pyzipper.AESZipFile(io.BytesIO(zip_data), 'r', encryption=pyzipper.WZ_AES) as zf:
        zf.setpassword(password.encode())
        zf.extractall(output_path)
    
    cursor.close()
    conn.close()
    print(f"File {file_id} fetched and saved to {output_path}")



@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))


@main.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form.get('username')
        email = request.form.get('email')
        password = request.form.get('password')
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        hashed_password = generate_password_hash(password, method='pbkdf2:sha256')

        new_user = User(username=username, email=email, password=hashed_password, first_name=first_name, last_name=last_name)
        db.session.add(new_user)
        db.session.commit()

        flash('Account created successfully!', 'success')
        return redirect(url_for('main.login'))
    return render_template('register.html')

@main.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        email = request.form.get('email')
        password = request.form.get('password')
        user = User.query.filter_by(email=email).first()

        if user and check_password_hash(user.password, password):
            login_user(user)
            return redirect(url_for('main.index'))
        else:
            flash('Login failed. Check your credentials and try again.', 'danger')
    return render_template('login.html')

@main.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect(url_for('main.index'))

@main.route('/account', methods=['GET', 'POST'])
@login_required
def account():
    user = current_user
    if request.method == 'POST':
        user.first_name = request.form.get('first_name')
        user.last_name = request.form.get('last_name')
        user.email = request.form.get('email')
        db.session.commit()
        flash('Account details updated successfully!', 'success')
        return redirect(url_for('main.account'))
    return render_template('account.html', user=user)

@main.route('/')
def index():
    total_files = FileContent.query.count()
    total_users = User.query.count()
    recent_activities = FileContent.query.order_by(FileContent.id.desc()).limit(5).all()
    total_processed_files = FileContent.query.filter(FileContent.analysis_status == 'completed').count()

    file_sizes = [file.file_size for file in FileContent.query.all()]

    bins = [0, 10**6, 10**7, 10**8, 10**9]
    hist, bin_edges = np.histogram(file_sizes, bins=bins)
    
    bin_labels = [f"{bin_edges[i] / (1024**2):.1f}MB - {bin_edges[i+1] / (1024**2):.1f}MB" for i in range(len(bin_edges)-1)]
    
    return render_template('index.html',
                           total_files=total_files,
                           total_processed_files=total_processed_files,
                           total_users=total_users,
                           recent_activities=recent_activities,
                           histogram_counts=hist.tolist(),
                           histogram_labels=bin_labels)

@main.route('/about')
def about():
    return render_template('about.html')


def save_file(file, user_id):
    md5_hash = hashlib.md5()
    file_content = file.read()
    md5_hash.update(file_content)
    file.seek(0)
    file_hash = md5_hash.hexdigest()

    filename = secure_filename(file_hash)

    file_size = len(file_content)

    # Zip file content
    password = 'infected'
    zip_content = zip_file(file_content, password, filename)

    new_file = FileContent(original_filename=file.filename,
        filename=filename,
        data=zip_content,
        analysis_status='pending',
        file_size=file_size,
        uploaded_by=user_id)
    

    db.session.add(new_file)
    db.session.commit()

    return filename, new_file

@main.route('/upload', methods=['GET', 'POST'])
@login_required
def upload():
    if request.method == 'POST':
        if 'files' not in request.files:
            flash('No file part')
            return redirect(url_for('main.upload'))
        
        files = request.files.getlist('files')
        
        if not files or all(file.filename == '' for file in files):
            flash('No selected file')
            return redirect(url_for('main.upload'))
        
        # Get the selected script from the form
        selected_script = request.form.get('script')
        if not selected_script:
            flash('No script selected')
            return redirect(url_for('main.upload'))

        for file in files:
            if file:
                
                filename, new_file = save_file(file, current_user.id)

                try:
                    file_id = new_file.id
                    temp_dir = "/home/dml3483/WorkArea/MalwareBenchmarkDataset/TempFileFolder"
                    if not os.path.exists(temp_dir):
                        os.makedirs(temp_dir)
                    file_name = os.path.join(temp_dir, str(file_id))
                    fetch_file_from_db(file_id, file_name, 'infected')

                    script_path = f'/home/dml3483/WorkArea/MalwareBenchmarkDataset/{selected_script}'
                    option = "/home/dml3483/WorkArea/MalwareBenchmarkDataset/TempFileFolder/" + str(file_id) + "/" + filename

                    if platform.system() == 'Windows':
                        # Run in WSL for Windows
                        subprocess.run(['wsl', 'bash', '-c', f'"{script_path}" "{option}"'], capture_output=True, text=True)
                    else:
                        # Run directly for Unix-based systems
                        subprocess.run(['bash', script_path, option], capture_output=True, text=True)
                        
                    file_path = filename + ".json"

                    with open(file_path, 'r') as file:
                        json_string = file.read()  # Read the file content as a string
                    # Load the JSON data from the string
                    # data = json.loads(json_string)

                    new_file.analysis_status = 'completed'
                    new_file.analysis_results = json_string
                    db.session.commit()

                    flash('File successfully uploaded and queued for analysis')
                except Exception as e:
                    flash(f'Failed to upload and queue file for analysis: {e}', 'danger')
                    print(f'Failed to upload and analyze file: {e}')
                finally:
                    try:
                        shutil.rmtree(file_name)
                        os.remove(file_path)
                    except OSError as e:
                        print(f"Error deleting file {file_name}: {e}")
        return redirect(url_for('main.upload'))
    return render_template('upload.html')


@main.route('/download', methods=['GET', 'POST'])
@login_required
def download():
    if request.method == 'POST':
        search = request.form.get('search')
        files = FileContent.query.filter(FileContent.filename.contains(search)).all()
    else:
        files = FileContent.query.all()
    return render_template('download.html', files=files)

@main.route('/download/<int:file_id>')
@login_required
def download_file(file_id):
    file_data = FileContent.query.get(file_id)
    return send_file(BytesIO(file_data.data), download_name=f'{file_data.filename}.zip', as_attachment=True)

@main.route('/download/json/view/<int:file_id>')
@login_required
def view_json(file_id):
    file_data = FileContent.query.get(file_id)
    if not file_data:
        flash('File not found', 'danger')
        return redirect(url_for('main.download'))
    
    if file_data.analysis_results:
        #FUN GRAPH AREA
        data = json.loads(file_data.analysis_results)
        
        histogram = data.get('histogram', [])
        byteentropy = data.get('byteentropy', [])

        # Plot Histogram
        histogram_fig = go.Figure()
        histogram_fig.add_trace(go.Bar(x=list(range(len(histogram))), y=histogram))
        histogram_fig.update_layout(title='Histogram Visualization', xaxis_title='Value', yaxis_title='Frequency')

        histogram_graph = pio.to_html(histogram_fig, full_html=False)

        # Plot Byte Entropy
        byteentropy_fig = go.Figure()
        byteentropy_fig.add_trace(go.Bar(x=list(range(len(byteentropy))), y=byteentropy))
        byteentropy_fig.update_layout(title='Byte Entropy Visualization', xaxis_title='Value', yaxis_title='Frequency')

        byteentropy_graph = pio.to_html(byteentropy_fig, full_html=False)
        #END FUN GRAPH AREA
        return render_template('view_json.html', analysis_results=json.loads(file_data.analysis_results), file_id=file_id, histogram_graph=histogram_graph, byteentropy_graph=byteentropy_graph)
    else:
        flash('No analysis results available for this file', 'warning')
        return redirect(url_for('main.download'))
    
@main.route('/download/json/download/<int:file_id>')
@login_required
def download_json(file_id):
    file_data = FileContent.query.get(file_id)
    if not file_data or not file_data.analysis_results:
        flash('File not found or no analysis results available', 'danger')
        return redirect(url_for('main.download'))

    json_bytes = file_data.analysis_results.encode('utf-8')
    response = make_response(json_bytes)
    response.headers["Content-Disposition"] = f"attachment; filename=analysis_results_{file_id}.json"
    response.headers["Content-Type"] = "application/json"
    return response

