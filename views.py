# views.py

from flask import Blueprint, request, flash, redirect, url_for, render_template, jsonify, send_file, make_response
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user
from werkzeug.utils import secure_filename
from werkzeug.security import generate_password_hash, check_password_hash
from .models import FileContent, User
from .extensions import db, login_manager
from io import BytesIO
import json
import subprocess
import psycopg2
import uuid
from kubernetes import client, config
import os
import hashlib
import platform
import numpy as np
import pandas as pd
from sqlalchemy import func, create_engine
from sqlalchemy.orm import scoped_session, sessionmaker
import plotly.graph_objs as go
import plotly.io as pio
import pyzipper
import io
import shutil
import multiprocessing
from multiprocessing import Pool, Manager
from queue import Empty
import queue
import time
import logging
import concurrent.futures
import traceback

main = Blueprint('main', __name__)

def zip_file(file_content, password, filename):
    zip_buffer = io.BytesIO()
    with pyzipper.AESZipFile(zip_buffer, 'w', compression=pyzipper.ZIP_DEFLATED, encryption=pyzipper.WZ_AES) as zf:
        zf.setpassword(password.encode())
        zf.writestr(f'{filename}', file_content)
    return zip_buffer.getvalue()

# Function to fetch file from the database
def fetch_file_from_db(file_id, output_path, password):
    conn = psycopg2.connect(
        dbname=os.getenv('DB_NAME'),
        user=os.getenv('DB_USER'),
        password=os.getenv('A_PASSWORD'),
        host=os.getenv('DB_HOST'),
        port=os.getenv('DB_PORT')
    )
    cursor = conn.cursor()
    
    query = "SELECT data FROM file_content WHERE id = %s"
    cursor.execute(query, (file_id,))
    zip_data = cursor.fetchone()[0]
    
    with pyzipper.AESZipFile(io.BytesIO(zip_data), 'r', encryption=pyzipper.WZ_AES) as zf:
        zf.setpassword(password.encode())
        zf.extractall(output_path)
    
    cursor.close()
    conn.close()
    print(f"File {file_id} fetched and saved to {output_path}")



@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))


@main.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form.get('username')
        email = request.form.get('email')
        password = request.form.get('password')
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        hashed_password = generate_password_hash(password, method='pbkdf2:sha256')

        new_user = User(username=username, email=email, password=hashed_password, first_name=first_name, last_name=last_name)
        db.session.add(new_user)
        db.session.commit()

        flash('Account created successfully!', 'success')
        return redirect(url_for('main.login'))
    return render_template('register.html')

@main.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        email = request.form.get('email')
        password = request.form.get('password')
        user = User.query.filter_by(email=email).first()

        if user and check_password_hash(user.password, password):
            login_user(user)
            return redirect(url_for('main.index'))
        else:
            flash('Login failed. Check your credentials and try again.', 'danger')
    return render_template('login.html')

@main.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect(url_for('main.index'))

@main.route('/account', methods=['GET', 'POST'])
@login_required
def account():
    user = current_user
    if request.method == 'POST':
        user.first_name = request.form.get('first_name')
        user.last_name = request.form.get('last_name')
        user.email = request.form.get('email')
        db.session.commit()
        flash('Account details updated successfully!', 'success')
        return redirect(url_for('main.account'))
    return render_template('account.html', user=user)

@main.route('/')
def index():
    total_files = FileContent.query.count()
    total_users = User.query.count()
    recent_activities = FileContent.query.order_by(FileContent.id.desc()).limit(5).all()
    total_processed_files = FileContent.query.filter(FileContent.analysis_status == 'completed').count()

    file_sizes = [file.file_size for file in FileContent.query.all()]

    bins = [0, 10**6, 10**7, 10**8, 10**9]
    hist, bin_edges = np.histogram(file_sizes, bins=bins)
    
    bin_labels = [f"{bin_edges[i] / (1024**2):.1f}MB - {bin_edges[i+1] / (1024**2):.1f}MB" for i in range(len(bin_edges)-1)]
    
    return render_template('index.html',
                           total_files=total_files,
                           total_processed_files=total_processed_files,
                           total_users=total_users,
                           recent_activities=recent_activities,
                           histogram_counts=hist.tolist(),
                           histogram_labels=bin_labels)

@main.route('/about')
def about():
    return render_template('about.html')


def save_file(file, user_id):
    md5_hash = hashlib.md5()
    file_content = file.read()
    md5_hash.update(file_content)
    file.seek(0)
    file_hash = md5_hash.hexdigest()

    filename = secure_filename(file_hash)

    file_size = len(file_content)

    # Zip file content
    password = 'infected'
    zip_content = zip_file(file_content, password, filename)

    new_file = FileContent(original_filename=file.filename,
        filename=filename,
        data=zip_content,
        analysis_status='pending',
        file_size=file_size,
        uploaded_by=user_id)
    

    db.session.add(new_file)
    db.session.commit()

    return filename, new_file

logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

@main.route('/upload', methods=['GET', 'POST'])
@login_required
def upload():
    if request.method == 'POST':
        if 'files' not in request.files:
            flash('No file part')
            return redirect(url_for('main.upload'))
        
        files = request.files.getlist('files')
        
        if not files or all(file.filename == '' for file in files):
            flash('No selected file')
            return redirect(url_for('main.upload'))
        
        selected_script = request.form.get('script')
        if not selected_script:
            flash('No script selected')
            return redirect(url_for('main.upload'))

        # List to store futures
        futures = []
        
        # Function to execute the script asynchronously
        def execute_script(script_path, option, filename, file_id):
            try:
                subprocess.run(['bash', script_path, file_id, option], capture_output=True, text=True)
                for _ in range(10):
                    if os.path.exists(f'/home/dml3483/WorkArea/MalwareBenchmarkDataset/TempFileFolder/{file_id}/{filename}.json'):
                        return True
                    else:
                        time.sleep(1)
            except Exception as e:
                logging.error(f"Script execution failed: {e}")
                return False
            return False

        # Use ThreadPoolExecutor to handle asynchronous script execution
        with concurrent.futures.ThreadPoolExecutor() as executor:
            for file in files:
                if file:
                    filename, new_file = save_file(file, current_user.id)

                    try:
                        file_id = new_file.id
                        temp_dir = "/home/dml3483/WorkArea/MalwareBenchmarkDataset/TempFileFolder"
                        if not os.path.exists(temp_dir):
                            os.makedirs(temp_dir)

                        zip_dir = os.path.join(temp_dir, str(file_id))

                        fetch_file_from_db(file_id, zip_dir, 'infected')

                        script_path = f'/home/dml3483/WorkArea/MalwareBenchmarkDataset/{selected_script}'
                        option = os.path.join(temp_dir, str(file_id), filename)

                        # Submit the script execution to the executor
                        future = executor.submit(execute_script, script_path, option, filename,str(file_id))
                        futures.append((future, new_file, filename, zip_dir))
                    
                    except Exception as e:
                        flash(f'Failed to upload and queue file for analysis: {e}', 'danger')
                        print(f'Failed to upload and analyze file: {e}')
        
        # Wait for all script executions to complete and handle results
        for future, new_file, filename, zip_dir in futures:
            try:
                print(f"Processing future: {future}")
                print(f"Associated new_file object: {new_file}")
                print(f"Original filename: {filename}")
                print(f"Temporary file path: {zip_dir}")
                print(f"Expected JSON output path: {zip_dir}/{filename}.json")
                success = future.result()
                if success:
                    file_path = zip_dir + filename + ".json"

                    with open(file_path, 'r') as file:
                        json_string = file.read()

                    new_file.analysis_status = 'completed'
                    new_file.analysis_results = json_string
                    db.session.commit()

                    flash('File successfully uploaded and queued for analysis')
                else:
                    flash('Script execution failed for a file', 'danger')
                    print('Script execution failed for a file')
            except Exception as e:
                flash(f'Error processing file: {e}', 'danger')
                print(f'Error processing file: {e}')
            finally:
                try:
                    shutil.rmtree(zip_dir)
                    #os.remove(file_path)
                except OSError as e:
                    print(f"Error deleting file {zip_dir}: {e}")

        return redirect(url_for('main.upload'))
    return render_template('upload.html')


@main.route('/download', methods=['GET', 'POST'])
@login_required
def download():
    filters = []

    if request.method == 'POST':
        filename_search = request.form.get('filename_search')
        original_filename_search = request.form.get('original_filename_search')
        uploader_search = request.form.get('uploader_search')
        status_search = request.form.get('status_search')

        if filename_search:
            filters.append(FileContent.filename.contains(filename_search))
        if original_filename_search:
            filters.append(FileContent.original_filename.contains(original_filename_search))
        if uploader_search:
            filters.append(User.username.contains(uploader_search))
        if status_search:
            filters.append(FileContent.analysis_status == status_search)

    files = FileContent.query.join(User).filter(*filters).all()

    return render_template('download.html', files=files)

@main.route('/download/<int:file_id>')
@login_required
def download_file(file_id):
    file_data = FileContent.query.get(file_id)
    return send_file(BytesIO(file_data.data), download_name=f'{file_data.filename}.zip', as_attachment=True)

@main.route('/download/json/view/<int:file_id>')
@login_required
def view_json(file_id):
    file_data = FileContent.query.get(file_id)
    if not file_data:
        flash('File not found', 'danger')
        return redirect(url_for('main.download'))
    
    if file_data.analysis_results:
        #FUN GRAPH AREA
        data = json.loads(file_data.analysis_results)
        
        histogram = data.get('histogram', [])
        byteentropy = data.get('byteentropy', [])

        # Plot Histogram
        histogram_fig = go.Figure()
        histogram_fig.add_trace(go.Bar(x=list(range(len(histogram))), y=histogram))
        histogram_fig.update_layout(title='Histogram Visualization', xaxis_title='Value', yaxis_title='Frequency')

        histogram_graph = pio.to_html(histogram_fig, full_html=False)

        # Plot Byte Entropy
        byteentropy_fig = go.Figure()
        byteentropy_fig.add_trace(go.Bar(x=list(range(len(byteentropy))), y=byteentropy))
        byteentropy_fig.update_layout(title='Byte Entropy Visualization', xaxis_title='Value', yaxis_title='Frequency')

        byteentropy_graph = pio.to_html(byteentropy_fig, full_html=False)
        #END FUN GRAPH AREA
        return render_template('view_json.html', analysis_results=json.loads(file_data.analysis_results), file_id=file_id, histogram_graph=histogram_graph, byteentropy_graph=byteentropy_graph)
    else:
        flash('No analysis results available for this file', 'warning')
        return redirect(url_for('main.download'))
    
@main.route('/download/json/download/<int:file_id>')
@login_required
def download_json(file_id):
    file_data = FileContent.query.get(file_id)
    if not file_data or not file_data.analysis_results:
        flash('File not found or no analysis results available', 'danger')
        return redirect(url_for('main.download'))

    json_bytes = file_data.analysis_results.encode('utf-8')
    response = make_response(json_bytes)
    response.headers["Content-Disposition"] = f"attachment; filename=analysis_results_{file_id}.json"
    response.headers["Content-Type"] = "application/json"
    return response