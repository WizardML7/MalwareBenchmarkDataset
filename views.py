# views.py

from flask import Blueprint, request, flash, redirect, url_for, render_template, jsonify, send_file
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user
from werkzeug.utils import secure_filename
from werkzeug.security import generate_password_hash, check_password_hash
from .models import FileContent, User
from .extensions import db, login_manager
from io import BytesIO
import json
import subprocess
import psycopg2
import uuid
from kubernetes import client, config
import os
import hashlib
import platform
import numpy as np
import pandas as pd
from sqlalchemy import func

main = Blueprint('main', __name__)


# Function to fetch file from the database
def fetch_file_from_db(file_id, output_path):
    conn = psycopg2.connect(
        dbname="binaries",
        user="postgres",
        password=os.getenv('A_PASSWORD'),
        host="localhost",
        port="5432"
    )
    cursor = conn.cursor()
    
    query = "SELECT data FROM file_content WHERE id = %s"
    cursor.execute(query, (file_id,))
    file_data = cursor.fetchone()[0]
    
    with open(output_path, 'wb') as file:
        file.write(file_data)
    
    cursor.close()
    conn.close()
    print(f"File {file_id} fetched and saved to {output_path}")


def calculate_file_hash(file_path):
    hash_md5 = hashlib.md5()
    with open(file_path, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_md5.update(chunk)
    return hash_md5.hexdigest()

def create_job_object(file_name, file_id):
    file_hash = calculate_file_hash(file_name)
    label_file_hash = file_hash

    container = client.V1Container(
        name="file-analyzer",
        image="wizardml7/linux-malware-analysis:latest",
        env=[
            client.V1EnvVar(name="FILE_NAME", value=file_name),
            client.V1EnvVar(name="FILE_ID", value=str(file_id)),
            client.V1EnvVar(name="FILE_HASH", value=file_hash)
        ],
        volume_mounts=[client.V1VolumeMount(mount_path="/home/app/input", name="file-volume", read_only=False)]
    )

    template = client.V1PodTemplateSpec(
        metadata=client.V1ObjectMeta(labels={
            "app": "file-analyzer",
            "file-hash": label_file_hash,
            "file-id": str(file_id)
        }),
        spec=client.V1PodSpec(
            restart_policy="Never",
            containers=[container],
            volumes=[
                client.V1Volume(
                    name="file-volume",
                    persistentVolumeClaim=client.V1PersistentVolumeClaimVolumeSource(claim_name="local-pvc")
                )
            ]
        )
    )

    spec = client.V1JobSpec(template=template, backoff_limit=4)

    job = client.V1Job(
        api_version="batch/v1",
        kind="Job",
        metadata=client.V1ObjectMeta(name=f"file-analysis-job-{uuid.uuid4()}"),
        spec=spec
    )

    return job

def create_job(api_instance, job):
    try:
        api_response = api_instance.create_namespaced_job(
            body=job,
            namespace="default")
        print("Job created. status='%s'" % str(api_response.status))
    except Exception as e:
        print(f"Failed to create job: {e}")

@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))


@main.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form.get('username')
        email = request.form.get('email')
        password = request.form.get('password')
        hashed_password = generate_password_hash(password, method='pbkdf2:sha256')

        new_user = User(username=username, email=email, password=hashed_password)
        db.session.add(new_user)
        db.session.commit()

        flash('Account created successfully!', 'success')
        return redirect(url_for('main.login'))
    return render_template('register.html')

@main.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        email = request.form.get('email')
        password = request.form.get('password')
        user = User.query.filter_by(email=email).first()

        if user and check_password_hash(user.password, password):
            login_user(user)
            return redirect(url_for('main.index'))
        else:
            flash('Login failed. Check your credentials and try again.', 'danger')
    return render_template('login.html')

@main.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect(url_for('main.index'))

@main.route('/')
def index():
    #TODO:ADD HISTOGRAM OF FILE SIZES. first make a file size attribute in the database
    total_files = FileContent.query.count()
    total_users = User.query.count()
    recent_activities = FileContent.query.order_by(FileContent.id.desc()).limit(5).all()
    total_processed_files = FileContent.query.filter(FileContent.analysis_status == 'completed').count()

    file_sizes = [file.file_size for file in FileContent.query.all()]

    bins = [0, 10**6, 10**7, 10**8, 10**9]
    hist, bin_edges = np.histogram(file_sizes, bins=bins)
    
    bin_labels = [f"{bin_edges[i] / (1024**2):.1f}MB - {bin_edges[i+1] / (1024**2):.1f}MB" for i in range(len(bin_edges)-1)]
    
    return render_template('index.html',
                           total_files=total_files,
                           total_processed_files=total_processed_files,
                           total_users=total_users,
                           recent_activities=recent_activities,
                           histogram_counts=hist.tolist(),
                           histogram_labels=bin_labels)

@main.route('/about')
def about():
    return render_template('about.html')


def save_file(file):
    md5_hash = hashlib.md5()
    file_content = file.read()
    md5_hash.update(file_content)
    file.seek(0)
    file_hash = md5_hash.hexdigest()

    filename = secure_filename(file_hash)

    file_size = len(file_content)

    new_file = FileContent(original_filename=file.filename,
        filename=filename,
        data=file_content,
        analysis_status='pending',
        file_size=file_size)
    

    db.session.add(new_file)
    db.session.commit()

    return filename, new_file

@main.route('/upload', methods=['GET', 'POST'])
@login_required
def upload():
    if request.method == 'POST':
        if 'files' not in request.files:
            flash('No file part')
            return redirect(url_for('main.upload'))
        
        files = request.files.getlist('files')
        
        if not files or all(file.filename == '' for file in files):
            flash('No selected file')
            return redirect(url_for('main.upload'))
        
        # Get the selected script from the form
        selected_script = request.form.get('script')
        if not selected_script:
            flash('No script selected')
            return redirect(url_for('main.upload'))

        for file in files:
            if file:
                
                filename, new_file = save_file(file)

                try:
                    file_id = new_file.id
                    temp_dir = "/home/dml3483/WorkArea/MalwareBenchmarkDataset/TempFileFolder"
                    if not os.path.exists(temp_dir):
                        os.makedirs(temp_dir)
                    file_name = os.path.join(temp_dir, str(file_id))
                    fetch_file_from_db(file_id, file_name)

                    script_path = f'/home/dml3483/WorkArea/MalwareBenchmarkDataset/{selected_script}'
                    option = "/home/dml3483/WorkArea/MalwareBenchmarkDataset/TempFileFolder/" + str(file_id)

                    if platform.system() == 'Windows':
                        # Run in WSL for Windows
                        subprocess.run(['wsl', 'bash', '-c', f'"{script_path}" "{option}"'], capture_output=True, text=True)
                    else:
                        # Run directly for Unix-based systems
                        subprocess.run(['bash', script_path, option], capture_output=True, text=True)
                        
                    file_path = str(file_id) + ".json"

                    with open(file_path, 'r') as file:
                        json_string = file.read()  # Read the file content as a string
                    # Load the JSON data from the string
                    # data = json.loads(json_string)

                    new_file.analysis_status = 'completed'
                    new_file.analysis_results = json_string
                    db.session.commit()

                    flash('File successfully uploaded and queued for analysis')
                except Exception as e:
                    flash(f'Failed to upload and queue file for analysis: {e}', 'danger')
                    print(f'Failed to upload and analyze file: {e}')
                finally:
                    try:
                        os.remove(file_name)
                    except OSError as e:
                        print(f"Error deleting file {file_name}: {e}")
        return redirect(url_for('main.upload'))
    return render_template('upload.html')


@main.route('/download', methods=['GET', 'POST'])
@login_required
def download():
    if request.method == 'POST':
        search = request.form.get('search')
        files = FileContent.query.filter(FileContent.filename.contains(search)).all()
    else:
        files = FileContent.query.all()
    return render_template('download.html', files=files)

@main.route('/download/<int:file_id>')
@login_required
def download_file(file_id):
    file_data = FileContent.query.get(file_id)
    return send_file(BytesIO(file_data.data), download_name=file_data.filename, as_attachment=True)

@main.route('/download/json/<int:file_id>')
@login_required
def view_json(file_id):
    file_data = FileContent.query.get(file_id)
    if not file_data:
        flash('File not found', 'danger')
        return redirect(url_for('main.download'))
    
    if file_data.analysis_results:
        return render_template('view_json.html', analysis_results=file_data.analysis_results)
    else:
        flash('No analysis results available for this file', 'warning')
        return redirect(url_for('main.download'))