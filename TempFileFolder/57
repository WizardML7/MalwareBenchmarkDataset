;Domenic Lo Iacono
;CSEC 202.03
;ASM_2
;1) Zero Flag
;I moved 22 into the eax register and then used the sub function to subtract 22 from the eax register. When the eax register holds the value 0 after the sub function the zero flag is turned on
mov eax, 22		;Moved 22 into eax
sub eax, 22		;Subtracted 22 from eax to get 0 in eax

;2) Sign Flag
;I moved 22 into the eax register and then used the sub function to subtract 23 from the eax register. When the eax register holds the value -1 after the sub function the sign flag is turned on
mov eax, 22		;Moved 22 into eax
sub eax, 23		;Subtracted 23 from eax to get -1 as the signed integer in eax

;3) Carry Flag
;I moved 23 into the eax register and then used the sub function to subtract 24 from the eax register. When the eax register holds the value -1 after the sub function the carry flag is turned on
mov eax, 23		;Moved 23 into eax
sub eax, 24		;Subtracted 24 from eax to get the unsigned integer 4294967295 in eax
;The exact same operation can be used to show as an example for the Sign and Carry flag. This is because the conditions for the Sign and Carry flag are both met when a register has a positive value 
;That is subtracted a value greater than it resulting in the signed integer being negative. The Carry flag is turned on because any negative number is too small for the unsigned value. 
;The Sign flag is turned on because the sign of the signed integer changed from positive to negative. 

;4) Overflow Flag
;I moved 32767 or 7FFF to the dx register and then used the add function to add one. Because the dx register can only hold a signed value of up to 32767 when one was added the overflow flag turned on. 
mov dx, 32767
add dx, 1

;5) AND
;Using an AND statement with one of the operands as the value one is a perfect way to test if the other operand is even or odd. 
mov eax, 1	;Move 1 into the eax register
mov ebx, 2	;Move a number, in this case 2 into the ebx register
and eax,ebx		;Use the and instruction and get the final result in the eax register. Because the rightmost bit in the eax register is not a one we know that the value in ebx is even. 

;6) OR
;Using the OR statement it is possible to quickly set a side of the registers to all ones while preserving the other parts of the register. 
mov eax, 10000000000000000000000000000000b		;Move 80000000h into eax
mov ebx, 1111111111111111b			;Move 0000FFFFh into ebx
or eax, ebx		;Use the OR statement to quickly switch and zeros in the lower half of the eax register to a one

;7) NOT
;Using a combination of the NOT instruction and the ADD function it is possible to manipulate a signed value to be the equivalant to multiplying by -1. 
mov eax, 500	;Move 500 to eax
not eax			;Use the NOT instruction to flip all the bits in the eax register
add eax, 1		;Use the add function to add 1 to the result. In this examplt the final signed result is -500. 

;8) TEST
;Almost exactly the same as the AND instruction the TEST instruction does the same operation without overwriting what is currently in eax
mov eax, 13		;Moving value into eax
test eax, 1		;Using TEST instruction with a one to test if the value in eax is odd or even
;jz ValueFound

;9) CMP
;The compare function will set the zero flag to 1 if the destination and source are equal. It will also set the carry flag to 1 if the source is greater than the destination. Lastly, it will leave both flags off if the destination is greater than the source
mov eax, 2		;Moving 2 to eax
mov ebx, 2		;Moving 2 to ebx
cmp eax, ebx		;Using the CMP instruction to compare the eax and ebx registers. Because they both hold the value 2, the zero flag is flipped on. 

;10) 10*7
mov eax,10		;Moving 10 into the eax register
mov ecx,10		;Moving 10 into the ecx register
shl ecx, 3		;Preforming a shift left using shl. This is with the arugment three which will have the same effect as multiplying by 8 or 2^3
sub ecx, eax	;Using the sub function to subtract 10 from 80 which accounts for the needed difference. This then gives a final answer of 70 in the ecx register. 


;11) -50*4
mov eax,  -50	;Moving -50 into the eax register
shl eax, 2		;Using the shl instruction with an argument of 2 to multiply the value in eax by 4 or 2^2. This gives a final value of -200 in the eax register. 


;12) 8/8
mov eax, 8		;Moving 8 into the eax register
shr eax, 3		;Preforming a shift right using shr with an argument of 3 in order to have the same effect as dividing by 8 or 2^3. This gives a final value of 1 in the eax register. 


;13) -21/10
;The solution below does not account for the remainder but does give the correct quotient. It does this using the shift arithmitic right function which is paramount when preserving the sign is needed. Also 21 is not evenly divisible by a power of two so the power of two 
;Over the desired number is chosen in this case 16 or 2^4
mov eax, -21
sar eax, 4


;14) INC
;Using the inc instruction it is possible to give a very similar example to the previous overflow example. This is important as it should be noted that the overflow flag can still occur with the inc instruction. 
mov ax, 32767 ;Moving 32767 to the ax register
Inc ax

;15) DEC
;Using the dec instruction it is possible to display how the zero flag is turned on by decrementing a register with a value of one. This is very useful in loops 
mov eax, 1
dec eax