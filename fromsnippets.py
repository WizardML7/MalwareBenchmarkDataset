import sys
sys.path.append('/data/rinaldo/ghidrascripting/ghidra/lib/python2.7/site-packages/')
import networkx as nx
import json
import os


from ghidra.app.script import GhidraScript
import ghidra.app.util.headless.HeadlessScript as HeadlessScript;
#from ghidra.app.util.headless import Headless
from ghidra.util.task import ConsoleTaskMonitor
from ghidra.app.decompiler import DecompileOptions, DecompInterface
from ghidra.program.model.pcode import PcodeOp

#class Post(HeadlessScript):
#    def __init__(self):
#        super(Post,self).__init__()
#    def run(self):
#        if analysisTimeoutOccurred():
#            exit(1)

def buildAST(func):
    options = DecompileOptions()
    monitor = ConsoleTaskMonitor()
    ifc = DecompInterface()
    ifc.setOptions(options)
    ifc.openProgram(getCurrentProgram())
    ifc.setSimplificationStyle("normalize")
    res = ifc.decompileFunction(func, 60, monitor)
    high = res.getHighFunction()
    return high

def buildGraph(graph, func, high):
    vertices = {}
    opiter = getPcodeOpIterator(high)
    while opiter.hasNext():
        op = opiter.next()
        vert = createOpVertex(func, op, high)
        graph.add_node(vert)
        for i in range(0, op.getNumInputs()):
            opcode = op.getOpcode()
            if (i == 0 and (opcode == PcodeOp.LOAD or opcode == PcodeOp.STORE)):
                continue
            if (i == 1 and opcode == PcodeOp.INDIRECT):
                continue
            vn = op.getInput(i)
            if (vn != None):
                v = getVarnodeVertex(graph, vertices, vn)
                graph.add_edge(v, vert)

        outvn = op.getOutput()
        if (outvn != None):
            outv = getVarnodeVertex(graph, vertices, outvn)
            if (outv != None):
                graph.add_edge(vert, outv)

def createOpVertex(func, op, high):
    name = op.getMnemonic()
    id = getOpKey(op)
    opcode = op.getOpcode()
    if ((opcode == PcodeOp.LOAD) or (opcode == PcodeOp.STORE)):
        vn = op.getInput(0)
        addrspace = currentProgram.getAddressFactory().getAddressSpace(vn.getOffset())
        name += ' ' + addrspace.getName()
    elif (opcode == PcodeOp.INDIRECT):
        vn = op.getInput(1)
        if (vn != None):
            indOp = high.getOpRef(vn.getOffset())
            if (indOp != None):
                name += " (" + indOp.getMnemonic() + ")"
    return "{}_{}".format(name, id)

def createVarnodeVertex(graph, vn):
    name = str(vn.getAddress())
    id = getVarnodeKey(vn)
    if (vn.isRegister()):
        reg = currentProgram.getRegister(vn.getAddress(), vn.getSize())
        if (reg != None):
            name = reg.getName()
    return "{}_{}".format(name, id)

def getVarnodeVertex(graph, vertices, vn):
    res = None
    try:
        res = vertices[str(vn.getUniqueId())]
    except KeyError:
        res = None
    if (res == None):
        res = createVarnodeVertex(graph, vn)
        vertices[str(vn.getUniqueId())] = res
    return res

def getAddress(offset):
    return currentProgram.getAddressFactory().getDefaultAddressSpace().getAddress(offset)

def getOpKey(op):
    sq = op.getSeqnum()
    id = str(sq.getTarget()) + " o " + str(op.getSeqnum().getTime())
    return id

def getPcodeOpIterator(high):
    return high.getPcodeOps()

def getVarnodeKey(vn):
    op = vn.getDef()
    id = ""
    if (op != None):
        id = str(op.getSeqnum().getTarget()) + " v " + str(vn.getUniqueId())
    else:
        id = "i v " + str(vn.getUniqueId())
    return id

def main():
    #outpath = "/home/rin/code/schoolCode/NNMalwareStudy/graphnetProcessing/ghidraoutput/"
    outpath = "/data/rinaldo/graphmaking_output/"
    if os.path.isfile(outpath + currentProgram.getName() + "_functiongraphsPCODE.json"):
        print("Program graph file already exists!","Skipping program", currentProgram.getName())
        exit(1)
    #if Headless.analysisTimeoutOccurred(currentProgram):
    #    print("Program", currentProgram.getName(), "analysis timed out")
    #    exit(1)
    graphs = []
    fm = currentProgram.getFunctionManager()
    #graph = nx.DiGraph()
    listing = currentProgram.getListing()
    #func = getFunctionContaining(getAddress(0x00100690))
    funcs = fm.getFunctions(True)
    print("Mining graphs from functions in program", currentProgram.getName())
    for f in funcs:
	graph = nx.DiGraph()
        high = buildAST(f)
        buildGraph(graph, f, high)
	graphs.append((f.getName(),nx.node_link_data(graph)))
    	#print("Finished building graph of function", f.getName(),"Number of nodes:", len(graph.nodes), "Number of edges:", len(graph.edges))
    try:
        with open(outpath + currentProgram.getName() + "_functiongraphsPCODE.json", "a") as file:
	    outdict = {"programName" : currentProgram.getName(), "functionGraphs" : graphs}
	    file.write(json.dumps(outdict)) 
    except Exception as e:
        print("error", e)
        print("Program graph file already exists!","Skipping program", currentProgram.getName())
#p = Post()
#p.run()
main()
